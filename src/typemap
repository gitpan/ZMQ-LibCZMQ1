# Do NOT edit this file! This file was automatically generated
# by Makefile.PL on Mon Jan  7 18:33:50 2013. If you want to
# regenerate it, remove this file and re-run Makefile.PL

TYPEMAP

const void * T_PV
Bool         T_BOOL
byte *       T_PV
PerlLibCZMQ1_zsocket_raw* PERLCZMQ_ZSOCKET_RAW
PerlLibCZMQ1_zctx* T_PERLLIBCZMQ1_ZCTX
PerlLibCZMQ1_zsocket* T_PERLLIBCZMQ1_ZSOCKET
PerlLibCZMQ1_zframe* T_PERLLIBCZMQ1_ZFRAME
PerlLibCZMQ1_zmsg* T_PERLLIBCZMQ1_ZMSG


INPUT

PERLCZMQ_ZSOCKET_RAW
    {
        MAGIC *mg;
        $var = NULL;
        if (! sv_isobject($arg)) {
            croak(\"Argument is not an object\");
        }

        /* if it got here, it's a blessed reference. better be an HV */
        {
            SV *svr;
            SV **closed;
            svr = SvRV($arg);
            if (! svr ) {
                croak(\"PANIC: Could not get reference from blessed object.\");
            }

            if (SvTYPE(svr) != SVt_PVHV) {
                croak(\"PANIC: Underlying storage of blessed reference is not a hash.\");
            }

            closed = hv_fetchs( (HV *) svr, \"_closed\", 0 );
            if (closed != NULL && SvTRUE(*closed)) {
                /* if it's already closed, just return */
                XSRETURN_EMPTY;
            }
        }

        mg = PerlLibCZMQ1_zsocket_mg_find(aTHX_ SvRV($arg));
        if (mg) {
            if (mg->mg_ptr == NULL)
                croak(\"Invalid ZMQ::LibCZMQ1::zsocket object (perhaps you've already freed it?)\");
            $var = ((PerlLibCZMQ1_zsocket *) mg->mg_ptr)->socket;
        }

        if ($var == NULL)
            croak(\"Invalid ZMQ::LibCZMQ1::zsocket object (perhaps you've already freed it?)\");
    }

T_PERLLIBCZMQ1_ZCTX
    {
        MAGIC *mg;
        $var = NULL;
        if (! sv_isobject($arg)) {
            croak(\"Argument is not an object\");
        }

        /* if it got here, it's a blessed reference. better be an HV */
        {
            SV *svr;
            SV **closed;
            svr = SvRV($arg);
            if (! svr ) {
                croak(\"PANIC: Could not get reference from blessed object.\");
            }

            if (SvTYPE(svr) != SVt_PVHV) {
                croak(\"PANIC: Underlying storage of blessed reference is not a hash.\");
            }

            closed = hv_fetchs( (HV *) svr, \"_closed\", 0 );
            if (closed != NULL && SvTRUE(*closed)) {
                /* if it's already closed, just return */
                XSRETURN_EMPTY;
            }
        }

        mg = PerlLibCZMQ1_zctx_mg_find(aTHX_ SvRV($arg));
        if (mg) {
            $var = (PerlLibCZMQ1_zctx *) mg->mg_ptr;
        }

        if ($var == NULL)
            croak(\"Invalid ZMQ::LibCZMQ1::Zctx object (perhaps you've already freed it?)\");
    }

T_PERLLIBCZMQ1_ZSOCKET
    {
        MAGIC *mg;
        $var = NULL;
        if (! sv_isobject($arg)) {
            croak(\"Argument is not an object\");
        }

        /* if it got here, it's a blessed reference. better be an HV */
        {
            SV *svr;
            SV **closed;
            svr = SvRV($arg);
            if (! svr ) {
                croak(\"PANIC: Could not get reference from blessed object.\");
            }

            if (SvTYPE(svr) != SVt_PVHV) {
                croak(\"PANIC: Underlying storage of blessed reference is not a hash.\");
            }

            closed = hv_fetchs( (HV *) svr, \"_closed\", 0 );
            if (closed != NULL && SvTRUE(*closed)) {
                /* if it's already closed, just return */
                XSRETURN_EMPTY;
            }
        }

        mg = PerlLibCZMQ1_zsocket_mg_find(aTHX_ SvRV($arg));
        if (mg) {
            $var = (PerlLibCZMQ1_zsocket *) mg->mg_ptr;
        }

        if ($var == NULL)
            croak(\"Invalid ZMQ::LibCZMQ1::Zsocket object (perhaps you've already freed it?)\");
    }

T_PERLLIBCZMQ1_ZFRAME
    {
        MAGIC *mg;
        $var = NULL;
        if (! sv_isobject($arg)) {
            croak(\"Argument is not an object\");
        }

        /* if it got here, it's a blessed reference. better be an HV */
        {
            SV *svr;
            SV **closed;
            svr = SvRV($arg);
            if (! svr ) {
                croak(\"PANIC: Could not get reference from blessed object.\");
            }

            if (SvTYPE(svr) != SVt_PVHV) {
                croak(\"PANIC: Underlying storage of blessed reference is not a hash.\");
            }

            closed = hv_fetchs( (HV *) svr, \"_closed\", 0 );
            if (closed != NULL && SvTRUE(*closed)) {
                /* if it's already closed, just return */
                XSRETURN_EMPTY;
            }
        }

        mg = PerlLibCZMQ1_zframe_mg_find(aTHX_ SvRV($arg));
        if (mg) {
            $var = (PerlLibCZMQ1_zframe *) mg->mg_ptr;
        }

        if ($var == NULL)
            croak(\"Invalid ZMQ::LibCZMQ1::Zframe object (perhaps you've already freed it?)\");
    }

T_PERLLIBCZMQ1_ZMSG
    {
        MAGIC *mg;
        $var = NULL;
        if (! sv_isobject($arg)) {
            croak(\"Argument is not an object\");
        }

        /* if it got here, it's a blessed reference. better be an HV */
        {
            SV *svr;
            SV **closed;
            svr = SvRV($arg);
            if (! svr ) {
                croak(\"PANIC: Could not get reference from blessed object.\");
            }

            if (SvTYPE(svr) != SVt_PVHV) {
                croak(\"PANIC: Underlying storage of blessed reference is not a hash.\");
            }

            closed = hv_fetchs( (HV *) svr, \"_closed\", 0 );
            if (closed != NULL && SvTRUE(*closed)) {
                /* if it's already closed, just return */
                XSRETURN_EMPTY;
            }
        }

        mg = PerlLibCZMQ1_zmsg_mg_find(aTHX_ SvRV($arg));
        if (mg) {
            $var = (PerlLibCZMQ1_zmsg *) mg->mg_ptr;
        }

        if ($var == NULL)
            croak(\"Invalid ZMQ::LibCZMQ1::Zmsg object (perhaps you've already freed it?)\");
    }



OUTPUT

T_PERLLIBCZMQ1_ZCTX
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZMQ::LibCZMQ1::Zctx\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlLibCZMQ1_zctx_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }

T_PERLLIBCZMQ1_ZSOCKET
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZMQ::LibCZMQ1::Zsocket\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlLibCZMQ1_zsocket_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }

T_PERLLIBCZMQ1_ZFRAME
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZMQ::LibCZMQ1::Zframe\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlLibCZMQ1_zframe_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }

T_PERLLIBCZMQ1_ZMSG
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZMQ::LibCZMQ1::Zmsg\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlLibCZMQ1_zmsg_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }


